rdat <-rdat[complete.cases(rdat[ , c("depth", "Bsalinity","exposu")]),]
rdat$surface_SAR[is.na(rdat$surface_SAR)] <- 0
rdat <- subset(rdat, rdat$surface_SAR > 0)
rdat$depth[rdat$depth > -0.5] <- -0.5
Depth<-log(abs(rdat$depth-1))
Salinity<-rdat$Bsalinity/10
Stress<-log(rdat$expos+1)
# load the longevity model outcome coefficients
setwd("C:/Users/pdvd/Online for git/Baltic/Processed data/")
load("Model_output_whole_community.Rdata")
# combine all data
longclasses <- c(10^-100,1,2,3,4,5,6,7,8,9,10,11,12,13,14)
nb <- length(longclasses)-1
# get longevity estimates from the sampling coefficients
library(rje)
b0<-modcf[1,3] ; b1<-modcf[2,3]
b2<-modcf[3,3] ; b3<-modcf[4,3]
b4<-modcf[5,3] ; b5<-modcf[6,3]
b6<-modcf[7,3] ; b7<-modcf[8,3]
datnew <- matrix(data=NA, ncol=nb+1, nrow=nrow(rdat))
for(i in 1:nb){
llst<-log(longclasses[i])
llend <- log(longclasses[i+1])
datnew[,i] <-expit(b0+b5*llend*Salinity+b6*Depth*Salinity+b4*Stress+b3*Depth+b2*Salinity+b1*llend+b7*llend*Depth)-
expit(b0+b5*llst*Salinity+b6*Depth*Salinity+b4*Stress+b3*Depth+b2*Salinity+b1*llst+b7*llst*Depth)
}
datnew[,15] <- 1- rowSums(datnew[,1:14])
# get fishing conditions
griddat <- data.frame(squares=rdat$squares,SAR=rdat$surface_SAR)
# number of classes
longclasses <- c(1:15)
state_avg <- matrix(data=NA,nrow=nrow(rdat),ncol=1)
Recov <- 5.31/longclasses
depBT <- griddat$SAR * 0.06
# calculate state for the whole community
dat <-as.data.frame(matrix(data=NA,nrow=nrow(rdat),ncol=15))
for(i in 1:15){
dat[,i]<-datnew[,i]*(1-depBT/Recov[i])
}
dat[dat<0] <- 0
state_avg <- rowSums(dat)
state_fish <- data.frame(griddat$squares, state_avg)
# load balticgrid outcome
setwd("C:/Users/pdvd/Online for git/Baltic/Processed data")
load("balticgrid_state.RData")
balticgrid@data <- balticgrid@data[,-c(28)]
# combine balticgrid with calculated state at 25th and 75th quantile
balticgrid@data <- cbind(balticgrid@data, state_fish[match(balticgrid@data$squares, state_fish$griddat.squares),c(2)])
colnames(balticgrid@data)[28] <- "onof_state"
# get balticgrid
setwd("C:/Users/pdvd/Online for git/Baltic/Data")
load("balticgrid.RData")
# all negative oxygen to zero
balticgrid@data$oxygenautumn[balticgrid@data$oxygenautumn < 0]  <- 0
balticgrid@data$oxygenwinter[balticgrid@data$oxygenwinter < 0]  <- 0
balticgrid@data$oxygensummer[balticgrid@data$oxygensummer < 0]  <- 0
balticgrid@data$oxygenspring[balticgrid@data$oxygenspring < 0]  <- 0
balticgrid@data$min_oxygen[balticgrid@data$min_oxygen < 0]  <- 0
# get the relevant data
rdat <-as.data.frame(balticgrid)
rdat <-rdat[complete.cases(rdat[ , c("depth", "Bsalinity","exposu")]),]
rdat$surface_SAR[is.na(rdat$surface_SAR)] <- 0
rdat <- subset(rdat, rdat$surface_SAR > 0)
rdat$depth[rdat$depth > -0.5] <- -0.5
Depth<-log(abs(rdat$depth-1))
Salinity<-rdat$Bsalinity/10
Stress<-log(rdat$expos+1)
# load the longevity model outcome coefficients
setwd("C:/Users/pdvd/Online for git/Baltic/Processed data/")
load("Model_output_whole_community.Rdata")
# combine all data
longclasses <- c(10^-100,1,2,3,4,5,6,7,8,9,10,11,12,13,14)
nb <- length(longclasses)-1
# get longevity estimates from the sampling coefficients
library(rje)
b0<-modcf[1,3] ; b1<-modcf[2,3]
b2<-modcf[3,3] ; b3<-modcf[4,3]
b4<-modcf[5,3] ; b5<-modcf[6,3]
b6<-modcf[7,3] ; b7<-modcf[8,3]
datnew <- matrix(data=NA, ncol=nb+1, nrow=nrow(rdat))
for(i in 1:nb){
llst<-log(longclasses[i])
llend <- log(longclasses[i+1])
datnew[,i] <-expit(b0+b5*llend*Salinity+b6*Depth*Salinity+b4*Stress+b3*Depth+b2*Salinity+b1*llend+b7*llend*Depth)-
expit(b0+b5*llst*Salinity+b6*Depth*Salinity+b4*Stress+b3*Depth+b2*Salinity+b1*llst+b7*llst*Depth)
}
datnew[,15] <- 1- rowSums(datnew[,1:14])
# get fishing conditions
griddat <- data.frame(squares=rdat$squares,SAR=rdat$surface_SAR)
# number of classes
longclasses <- c(1:15)
state_avg <- matrix(data=NA,nrow=nrow(rdat),ncol=1)
Recov <- 5.31/longclasses
depBT <- griddat$SAR * 0.06
# calculate state for the whole community
dat <-as.data.frame(matrix(data=NA,nrow=nrow(rdat),ncol=15))
for(i in 1:15){
dat[,i]<-datnew[,i]*(1-depBT/Recov[i])
}
dat[dat<0] <- 0
state_avg <- rowSums(dat)
state_fish <- data.frame(griddat$squares, state_avg)
# load balticgrid outcome
setwd("C:/Users/pdvd/Online for git/Baltic/Processed data")
load("balticgrid_state.RData")
balticgrid@data <- balticgrid@data[,-c(28)]
# combine balticgrid with calculated state at 25th and 75th quantile
balticgrid@data <- cbind(balticgrid@data, state_fish[match(balticgrid@data$squares, state_fish$griddat.squares),c(2)])
colnames(balticgrid@data)[28] <- "onof_state02"
balticgrid@data$onof_state02[balticgrid@data$min_oxygen < 0.2] <- 0
balticgrid@data$onof_state04 <- balticgrid@data$onof_state02
balticgrid@data$onof_state04[balticgrid@data$min_oxygen < 0.4] <- 0
# get balticgrid
setwd("C:/Users/pdvd/Online for git/Baltic/Data")
load("balticgrid.RData")
# all negative oxygen to zero
balticgrid@data$oxygenautumn[balticgrid@data$oxygenautumn < 0]  <- 0
balticgrid@data$oxygenwinter[balticgrid@data$oxygenwinter < 0]  <- 0
balticgrid@data$oxygensummer[balticgrid@data$oxygensummer < 0]  <- 0
balticgrid@data$oxygenspring[balticgrid@data$oxygenspring < 0]  <- 0
balticgrid@data$min_oxygen[balticgrid@data$min_oxygen < 0]  <- 0
# get the relevant data
rdat <-as.data.frame(balticgrid)
rdat <-rdat[complete.cases(rdat[ , c("depth", "Bsalinity","exposu")]),]
rdat$surface_SAR[is.na(rdat$surface_SAR)] <- 0
rdat <- subset(rdat, rdat$surface_SAR > 0)
rdat$depth[rdat$depth > -0.5] <- -0.5
Depth<-log(abs(rdat$depth-1))
Salinity<-rdat$Bsalinity/10
Stress<-log(rdat$expos+1)
# load the longevity model outcome coefficients
setwd("C:/Users/pdvd/Online for git/Baltic/Processed data/")
load("Model_output_whole_community.Rdata")
# combine all data
longclasses <- c(10^-100,1,2,3,4,5,6,7,8,9,10,11,12,13,14)
nb <- length(longclasses)-1
# get longevity estimates from the sampling coefficients
library(rje)
b0<-modcf[1,3] ; b1<-modcf[2,3]
b2<-modcf[3,3] ; b3<-modcf[4,3]
b4<-modcf[5,3] ; b5<-modcf[6,3]
b6<-modcf[7,3] ; b7<-modcf[8,3]
datnew <- matrix(data=NA, ncol=nb+1, nrow=nrow(rdat))
for(i in 1:nb){
llst<-log(longclasses[i])
llend <- log(longclasses[i+1])
datnew[,i] <-expit(b0+b5*llend*Salinity+b6*Depth*Salinity+b4*Stress+b3*Depth+b2*Salinity+b1*llend+b7*llend*Depth)-
expit(b0+b5*llst*Salinity+b6*Depth*Salinity+b4*Stress+b3*Depth+b2*Salinity+b1*llst+b7*llst*Depth)
}
datnew[,15] <- 1- rowSums(datnew[,1:14])
# get fishing conditions
griddat <- data.frame(squares=rdat$squares,SAR=rdat$surface_SAR)
# number of classes
longclasses <- c(1:15)
state_avg <- matrix(data=NA,nrow=nrow(rdat),ncol=1)
Recov <- 5.31/longclasses
depBT <- griddat$SAR * 0.06
# calculate state for the whole community
dat <-as.data.frame(matrix(data=NA,nrow=nrow(rdat),ncol=15))
for(i in 1:15){
dat[,i]<-datnew[,i]*(1-depBT/Recov[i])
}
dat[dat<0] <- 0
state_avg <- rowSums(dat)
state_fish <- data.frame(griddat$squares, state_avg)
# load balticgrid outcome
setwd("C:/Users/pdvd/Online for git/Baltic/Processed data")
load("balticgrid_state.RData")
balticgrid@data <- balticgrid@data[,-c(28)]
# combine balticgrid with calculated state at 25th and 75th quantile
balticgrid@data <- cbind(balticgrid@data, state_fish[match(balticgrid@data$squares, state_fish$griddat.squares),c(2)])
colnames(balticgrid@data)[28] <- "onof_state1"
balticgrid@data$onof_state1[balticgrid@data$max_oxygen < 0.5] <- 0
balticgrid@data$onof_state2 <- balticgrid@data$onof_state1
# get balticgrid
setwd("C:/Users/pdvd/Online for git/Baltic/Data")
load("balticgrid.RData")
# all negative oxygen to zero
balticgrid@data$oxygenautumn[balticgrid@data$oxygenautumn < 0]  <- 0
balticgrid@data$oxygenwinter[balticgrid@data$oxygenwinter < 0]  <- 0
balticgrid@data$oxygensummer[balticgrid@data$oxygensummer < 0]  <- 0
balticgrid@data$oxygenspring[balticgrid@data$oxygenspring < 0]  <- 0
balticgrid@data$min_oxygen[balticgrid@data$min_oxygen < 0]  <- 0
# get the relevant data
rdat <-as.data.frame(balticgrid)
rdat <-rdat[complete.cases(rdat[ , c("depth", "Bsalinity","exposu")]),]
rdat$surface_SAR[is.na(rdat$surface_SAR)] <- 0
rdat <- subset(rdat, rdat$surface_SAR > 0)
rdat$depth[rdat$depth > -0.5] <- -0.5
Depth<-log(abs(rdat$depth-1))
Salinity<-rdat$Bsalinity/10
Stress<-log(rdat$expos+1)
# load the longevity model outcome coefficients
setwd("C:/Users/pdvd/Online for git/Baltic/Processed data/")
load("Model_output_whole_community.Rdata")
# combine all data
longclasses <- c(10^-100,1,2,3,4,5,6,7,8,9,10,11,12,13,14)
nb <- length(longclasses)-1
# get longevity estimates from the sampling coefficients
library(rje)
b0<-modcf[1,3] ; b1<-modcf[2,3]
b2<-modcf[3,3] ; b3<-modcf[4,3]
b4<-modcf[5,3] ; b5<-modcf[6,3]
b6<-modcf[7,3] ; b7<-modcf[8,3]
datnew <- matrix(data=NA, ncol=nb+1, nrow=nrow(rdat))
for(i in 1:nb){
llst<-log(longclasses[i])
llend <- log(longclasses[i+1])
datnew[,i] <-expit(b0+b5*llend*Salinity+b6*Depth*Salinity+b4*Stress+b3*Depth+b2*Salinity+b1*llend+b7*llend*Depth)-
expit(b0+b5*llst*Salinity+b6*Depth*Salinity+b4*Stress+b3*Depth+b2*Salinity+b1*llst+b7*llst*Depth)
}
datnew[,15] <- 1- rowSums(datnew[,1:14])
# get fishing conditions
griddat <- data.frame(squares=rdat$squares,SAR=rdat$surface_SAR)
# number of classes
longclasses <- c(1:15)
state_avg <- matrix(data=NA,nrow=nrow(rdat),ncol=1)
Recov <- 5.31/longclasses
depBT <- griddat$SAR * 0.06
# calculate state for the whole community
dat <-as.data.frame(matrix(data=NA,nrow=nrow(rdat),ncol=15))
for(i in 1:15){
dat[,i]<-datnew[,i]*(1-depBT/Recov[i])
}
dat[dat<0] <- 0
state_avg <- rowSums(dat)
state_fish <- data.frame(griddat$squares, state_avg)
# load balticgrid outcome
setwd("C:/Users/pdvd/Online for git/Baltic/Processed data")
load("balticgrid_state.RData")
balticgrid@data <- balticgrid@data[,-c(28)]
# combine balticgrid with calculated state at 25th and 75th quantile
balticgrid@data <- cbind(balticgrid@data, state_fish[match(balticgrid@data$squares, state_fish$griddat.squares),c(2)])
colnames(balticgrid@data)[28] <- "onof_state1"
balticgrid@data$onof_state1[balticgrid@data$max_oxygen < 0.3] <- 0
balticgrid@data$onof_state2 <- balticgrid@data$onof_state1
balticgrid@data$onof_state2[balticgrid@data$max_oxygen < 0.5] <- 0
save(balticgrid,file="balticgrid_state.RData")
# script to derive state per habitat type
# load balticgrid_state
setwd("C:/Users/pdvd/Online for git/Baltic/Processed data")
load("balticgrid_state.RData")
baltdat <- as.data.frame(balticgrid)
baltdat$Q25_state[is.na(baltdat$Q25_state) & !(is.na(baltdat$depth))] <- 1
baltdat$Q50_state[is.na(baltdat$Q50_state) & !(is.na(baltdat$depth))] <- 1
baltdat$Q75_state[is.na(baltdat$Q75_state) & !(is.na(baltdat$depth))] <- 1
baltdat$onof_state1[is.na(baltdat$onof_state1) & !(is.na(baltdat$depth))] <- 1
baltdat$onof_state2[is.na(baltdat$onof_state2) & !(is.na(baltdat$depth))] <- 1
# calculate for the whole baltic region
# first cut the edge
baltdat2 <- data.frame(longitude = coordinates(balticgrid)[,1], latitude = coordinates(balticgrid)[,2])
baltdat<-cbind(baltdat,baltdat2)
baltdat$knip<- rep(1,nrow(baltdat))
baltdat$knip[baltdat$longitude < 10.3 & baltdat$latitude > 57.3]<-NA
baltdat$knip[baltdat$longitude < 10 & baltdat$latitude > 56.5]<-NA
baltdat$knip[baltdat$longitude > 10 & baltdat$longitude<12 & baltdat$latitude > 57.8]<-NA
baltdat<-subset(baltdat,!(is.na(baltdat$knip)))
# now get average state
whole <- c(mean(baltdat$Q25_state,na.rm=T),mean(baltdat$Q50_state, na.rm=T),mean(baltdat$Q75_state, na.rm=T),mean(baltdat$onof_state1,na.rm=T),mean(baltdat$onof_state2,na.rm=T))
whole <- data.frame("whole region",whole[1],whole[2],whole[3],whole[4],whole[4],1,1)
colnames(whole) <-  c("msfd","stateQ25","stateQ50","stateQ75","stateonof1","stateonof2","fraction area","fraction_2dec")
# now per habitat
baltdat <- subset(baltdat,!(is.na(baltdat$depth)))
habitatQ25 <- aggregate(baltdat$Q25_state,by=list(baltdat$msfd_habitat),FUN="mean",na.rm=T)
habitatQ50 <- aggregate(baltdat$Q50_state,by=list(baltdat$msfd_habitat),FUN="mean",na.rm=T)
habitatQ75 <- aggregate(baltdat$Q75_state,by=list(baltdat$msfd_habitat),FUN="mean",na.rm=T)
habitatOnof1 <- aggregate(baltdat$onof_state1,by=list(baltdat$msfd_habitat),FUN="mean",na.rm=T)
habitatOnof2 <- aggregate(baltdat$onof_state2,by=list(baltdat$msfd_habitat),FUN="mean",na.rm=T)
habitat_tot <- cbind(habitatQ25,habitatQ50[,2],habitatQ75[,2],habitatOnof1[,2],habitatOnof2[,2])
# calculate total surface area
totarea <- aggregate(baltdat$area_sqkm,by=list(baltdat$msfd_habitat),FUN="sum",na.rm=T)
totarea$frac<-totarea$x/(sum(totarea$x))
totarea$frac2 <- round(totarea$frac, digits = 2)
habitat_tot <- cbind(habitat_tot,totarea$frac,totarea$frac2)
msfd_imp <- subset(habitat_tot,(habitat_tot$Group.1 %in% c("Circalittoral mixed sediment","Circalittoral mud",
"Offshore circalittoral mud","Circalittoral sand",
"Infralittoral mixed sediment","Offshore circalittoral mixed sediment")))
msfd_imp <- as.data.frame(msfd_imp)
colnames(msfd_imp) <-  c("msfd","stateQ25","stateQ50","stateQ75","stateonof1","stateonof2","fraction area","fraction_2dec")
msfd_imp$msfd <- as.character(msfd_imp$msfd)
#calculate weighted per surface area, average for the other regions
remreg <- subset(habitat_tot,!(habitat_tot$Group.1 %in% c("Circalittoral mixed sediment","Circalittoral mud",
"Offshore circalittoral mud","Circalittoral sand",
"Infralittoral mixed sediment","Offshore circalittoral mixed sediment")))
other <- remreg[,6]*remreg[,2:5]
other <- colSums(other)/sum(remreg[,6])
other <- data.frame("others",other[1],other[2],other[3],other[4],sum(remreg[,5]),sum(remreg[,6]))
colnames(other) <- c("msfd","stateQ25","stateQ50","stateQ75","stateonof1","stateonof2","fraction area","fraction_2dec")
statehabitat <- rbind(whole,msfd_imp,other)
statehabitat <- statehabitat[order(-statehabitat$fraction_2dec),]
# load balticgrid_state
setwd("C:/Users/pdvd/Online for git/Baltic/Processed data")
load("balticgrid_state.RData")
baltdat <- as.data.frame(balticgrid)
baltdat$Q25_state[is.na(baltdat$Q25_state) & !(is.na(baltdat$depth))] <- 1
baltdat$Q50_state[is.na(baltdat$Q50_state) & !(is.na(baltdat$depth))] <- 1
baltdat$Q75_state[is.na(baltdat$Q75_state) & !(is.na(baltdat$depth))] <- 1
baltdat$onof_state1[is.na(baltdat$onof_state1) & !(is.na(baltdat$depth))] <- 1
baltdat$onof_state2[is.na(baltdat$onof_state2) & !(is.na(baltdat$depth))] <- 1
# first cut the edge
baltdat2 <- data.frame(longitude = coordinates(balticgrid)[,1], latitude = coordinates(balticgrid)[,2])
baltdat<-cbind(baltdat,baltdat2)
baltdat$knip<- rep(1,nrow(baltdat))
baltdat$knip[baltdat$longitude < 10.3 & baltdat$latitude > 57.3]<-NA
baltdat$knip[baltdat$longitude < 10 & baltdat$latitude > 56.5]<-NA
baltdat$knip[baltdat$longitude > 10 & baltdat$longitude<12 & baltdat$latitude > 57.8]<-NA
baltdat<-subset(baltdat,!(is.na(baltdat$knip)))
# now get average state
whole <- c(mean(baltdat$Q25_state,na.rm=T),mean(baltdat$Q50_state, na.rm=T),mean(baltdat$Q75_state, na.rm=T),mean(baltdat$onof_state1,na.rm=T),mean(baltdat$onof_state2,na.rm=T))
whole <- data.frame("whole region",whole[1],whole[2],whole[3],whole[4],whole[5],1,1)
colnames(whole) <-  c("msfd","stateQ25","stateQ50","stateQ75","stateonof1","stateonof2","fraction area","fraction_2dec")
# now per habitat
baltdat <- subset(baltdat,!(is.na(baltdat$depth)))
habitatQ25 <- aggregate(baltdat$Q25_state,by=list(baltdat$msfd_habitat),FUN="mean",na.rm=T)
habitatQ50 <- aggregate(baltdat$Q50_state,by=list(baltdat$msfd_habitat),FUN="mean",na.rm=T)
habitatQ75 <- aggregate(baltdat$Q75_state,by=list(baltdat$msfd_habitat),FUN="mean",na.rm=T)
habitatOnof1 <- aggregate(baltdat$onof_state1,by=list(baltdat$msfd_habitat),FUN="mean",na.rm=T)
habitatOnof2 <- aggregate(baltdat$onof_state2,by=list(baltdat$msfd_habitat),FUN="mean",na.rm=T)
habitat_tot <- cbind(habitatQ25,habitatQ50[,2],habitatQ75[,2],habitatOnof1[,2],habitatOnof2[,2])
# calculate total surface area
totarea <- aggregate(baltdat$area_sqkm,by=list(baltdat$msfd_habitat),FUN="sum",na.rm=T)
totarea$frac<-totarea$x/(sum(totarea$x))
totarea$frac2 <- round(totarea$frac, digits = 2)
habitat_tot <- cbind(habitat_tot,totarea$frac,totarea$frac2)
msfd_imp <- subset(habitat_tot,(habitat_tot$Group.1 %in% c("Circalittoral mixed sediment","Circalittoral mud",
"Offshore circalittoral mud","Circalittoral sand",
"Infralittoral mixed sediment","Offshore circalittoral mixed sediment")))
msfd_imp <- as.data.frame(msfd_imp)
colnames(msfd_imp) <-  c("msfd","stateQ25","stateQ50","stateQ75","stateonof1","stateonof2","fraction area","fraction_2dec")
msfd_imp$msfd <- as.character(msfd_imp$msfd)
#calculate weighted per surface area, average for the other regions
remreg <- subset(habitat_tot,!(habitat_tot$Group.1 %in% c("Circalittoral mixed sediment","Circalittoral mud",
"Offshore circalittoral mud","Circalittoral sand",
"Infralittoral mixed sediment","Offshore circalittoral mixed sediment")))
other <- remreg[,7]*remreg[,2:6]
other <- colSums(other)/sum(remreg[,7])
other <- data.frame("others",other[1],other[2],other[3],other[4],sum(remreg[,5]),sum(remreg[,6]))
other
remreg
sum(remreg[,7])
sum(remreg[,8])
# script to derive state per habitat type
# load balticgrid_state
setwd("C:/Users/pdvd/Online for git/Baltic/Processed data")
load("balticgrid_state.RData")
baltdat <- as.data.frame(balticgrid)
baltdat$Q25_state[is.na(baltdat$Q25_state) & !(is.na(baltdat$depth))] <- 1
baltdat$Q50_state[is.na(baltdat$Q50_state) & !(is.na(baltdat$depth))] <- 1
baltdat$Q75_state[is.na(baltdat$Q75_state) & !(is.na(baltdat$depth))] <- 1
baltdat$onof_state1[is.na(baltdat$onof_state1) & !(is.na(baltdat$depth))] <- 1
baltdat$onof_state2[is.na(baltdat$onof_state2) & !(is.na(baltdat$depth))] <- 1
# calculate for the whole baltic region
# first cut the edge
baltdat2 <- data.frame(longitude = coordinates(balticgrid)[,1], latitude = coordinates(balticgrid)[,2])
baltdat<-cbind(baltdat,baltdat2)
baltdat$knip<- rep(1,nrow(baltdat))
baltdat$knip[baltdat$longitude < 10.3 & baltdat$latitude > 57.3]<-NA
baltdat$knip[baltdat$longitude < 10 & baltdat$latitude > 56.5]<-NA
baltdat$knip[baltdat$longitude > 10 & baltdat$longitude<12 & baltdat$latitude > 57.8]<-NA
baltdat<-subset(baltdat,!(is.na(baltdat$knip)))
# now get average state
whole <- c(mean(baltdat$Q25_state,na.rm=T),mean(baltdat$Q50_state, na.rm=T),mean(baltdat$Q75_state, na.rm=T),mean(baltdat$onof_state1,na.rm=T),mean(baltdat$onof_state2,na.rm=T))
whole <- data.frame("whole region",whole[1],whole[2],whole[3],whole[4],whole[5],1,1)
colnames(whole) <-  c("msfd","stateQ25","stateQ50","stateQ75","stateonof1","stateonof2","fraction area","fraction_2dec")
# now per habitat
baltdat <- subset(baltdat,!(is.na(baltdat$depth)))
habitatQ25 <- aggregate(baltdat$Q25_state,by=list(baltdat$msfd_habitat),FUN="mean",na.rm=T)
habitatQ50 <- aggregate(baltdat$Q50_state,by=list(baltdat$msfd_habitat),FUN="mean",na.rm=T)
habitatQ75 <- aggregate(baltdat$Q75_state,by=list(baltdat$msfd_habitat),FUN="mean",na.rm=T)
habitatOnof1 <- aggregate(baltdat$onof_state1,by=list(baltdat$msfd_habitat),FUN="mean",na.rm=T)
habitatOnof2 <- aggregate(baltdat$onof_state2,by=list(baltdat$msfd_habitat),FUN="mean",na.rm=T)
habitat_tot <- cbind(habitatQ25,habitatQ50[,2],habitatQ75[,2],habitatOnof1[,2],habitatOnof2[,2])
# calculate total surface area
totarea <- aggregate(baltdat$area_sqkm,by=list(baltdat$msfd_habitat),FUN="sum",na.rm=T)
totarea$frac<-totarea$x/(sum(totarea$x))
totarea$frac2 <- round(totarea$frac, digits = 2)
habitat_tot <- cbind(habitat_tot,totarea$frac,totarea$frac2)
msfd_imp <- subset(habitat_tot,(habitat_tot$Group.1 %in% c("Circalittoral mixed sediment","Circalittoral mud",
"Offshore circalittoral mud","Circalittoral sand",
"Infralittoral mixed sediment","Offshore circalittoral mixed sediment")))
msfd_imp <- as.data.frame(msfd_imp)
colnames(msfd_imp) <-  c("msfd","stateQ25","stateQ50","stateQ75","stateonof1","stateonof2","fraction area","fraction_2dec")
msfd_imp$msfd <- as.character(msfd_imp$msfd)
#calculate weighted per surface area, average for the other regions
remreg <- subset(habitat_tot,!(habitat_tot$Group.1 %in% c("Circalittoral mixed sediment","Circalittoral mud",
"Offshore circalittoral mud","Circalittoral sand",
"Infralittoral mixed sediment","Offshore circalittoral mixed sediment")))
other <- remreg[,7]*remreg[,2:6]
other <- colSums(other)/sum(remreg[,7])
other <- data.frame("others",other[1],other[2],other[3],other[4],other[5],sum(remreg[,7]),sum(remreg[,8]))
colnames(other) <- c("msfd","stateQ25","stateQ50","stateQ75","stateonof1","stateonof2","fraction area","fraction_2dec")
statehabitat <- rbind(whole,msfd_imp,other)
statehabitat <- statehabitat[order(-statehabitat$fraction_2dec),]
statehabitat
# get balticgrid
setwd("C:/Users/pdvd/Online for git/Baltic/Data")
load("balticgrid.RData")
# all negative oxygen to zero
balticgrid@data$oxygenautumn[balticgrid@data$oxygenautumn < 0]  <- 0
balticgrid@data$oxygenwinter[balticgrid@data$oxygenwinter < 0]  <- 0
balticgrid@data$oxygensummer[balticgrid@data$oxygensummer < 0]  <- 0
balticgrid@data$oxygenspring[balticgrid@data$oxygenspring < 0]  <- 0
balticgrid@data$min_oxygen[balticgrid@data$min_oxygen < 0]  <- 0
# get the relevant data
rdat <-as.data.frame(balticgrid)
rdat <-rdat[complete.cases(rdat[ , c("depth", "Bsalinity","exposu")]),]
rdat$surface_SAR[is.na(rdat$surface_SAR)] <- 0
rdat <- subset(rdat, rdat$surface_SAR > 0)
rdat$depth[rdat$depth > -0.5] <- -0.5
Depth<-log(abs(rdat$depth-1))
Salinity<-rdat$Bsalinity/10
Stress<-log(rdat$expos+1)
# load the longevity model outcome coefficients
setwd("C:/Users/pdvd/Online for git/Baltic/Processed data/")
load("Model_output_whole_community.Rdata")
# combine all data
longclasses <- c(10^-100,1,2,3,4,5,6,7,8,9,10,11,12,13,14)
nb <- length(longclasses)-1
# get longevity estimates from the sampling coefficients
library(rje)
b0<-modcf[1,3] ; b1<-modcf[2,3]
b2<-modcf[3,3] ; b3<-modcf[4,3]
b4<-modcf[5,3] ; b5<-modcf[6,3]
b6<-modcf[7,3] ; b7<-modcf[8,3]
datnew <- matrix(data=NA, ncol=nb+1, nrow=nrow(rdat))
for(i in 1:nb){
llst<-log(longclasses[i])
llend <- log(longclasses[i+1])
datnew[,i] <-expit(b0+b5*llend*Salinity+b6*Depth*Salinity+b4*Stress+b3*Depth+b2*Salinity+b1*llend+b7*llend*Depth)-
expit(b0+b5*llst*Salinity+b6*Depth*Salinity+b4*Stress+b3*Depth+b2*Salinity+b1*llst+b7*llst*Depth)
}
datnew[,15] <- 1- rowSums(datnew[,1:14])
# get fishing conditions
griddat <- data.frame(squares=rdat$squares,SAR=rdat$surface_SAR)
# number of classes
longclasses <- c(1:15)
state_avg <- matrix(data=NA,nrow=nrow(rdat),ncol=1)
Recov <- 5.31/longclasses
depBT <- griddat$SAR * 0.06
# calculate state for the whole community
dat <-as.data.frame(matrix(data=NA,nrow=nrow(rdat),ncol=15))
for(i in 1:15){
dat[,i]<-datnew[,i]*(1-depBT/Recov[i])
}
dat[dat<0] <- 0
state_avg <- rowSums(dat)
state_fish <- data.frame(griddat$squares, state_avg)
# load balticgrid outcome
setwd("C:/Users/pdvd/Online for git/Baltic/Processed data")
load("balticgrid_state.RData")
balticgrid@data <- balticgrid@data[,-c(28,29)]
# combine balticgrid with calculated state at 25th and 75th quantile
balticgrid@data <- cbind(balticgrid@data, state_fish[match(balticgrid@data$squares, state_fish$griddat.squares),c(2)])
colnames(balticgrid@data)[28] <- "onof_state1"
balticgrid@data$onof_state1[balticgrid@data$min_oxygen < 0.3] <- 0
balticgrid@data$onof_state2 <- balticgrid@data$onof_state1
balticgrid@data$onof_state2[balticgrid@data$min_oxygen < 0.5] <- 0
save(balticgrid,file="balticgrid_state.RData")
names(balticgrid)
# script to derive state per habitat type
# load balticgrid_state
setwd("C:/Users/pdvd/Online for git/Baltic/Processed data")
load("balticgrid_state.RData")
baltdat <- as.data.frame(balticgrid)
baltdat$Q25_state[is.na(baltdat$Q25_state) & !(is.na(baltdat$depth))] <- 1
baltdat$Q50_state[is.na(baltdat$Q50_state) & !(is.na(baltdat$depth))] <- 1
baltdat$Q75_state[is.na(baltdat$Q75_state) & !(is.na(baltdat$depth))] <- 1
baltdat$onof_state1[is.na(baltdat$onof_state1) & !(is.na(baltdat$depth))] <- 1
baltdat$onof_state2[is.na(baltdat$onof_state2) & !(is.na(baltdat$depth))] <- 1
# calculate for the whole baltic region
# first cut the edge
baltdat2 <- data.frame(longitude = coordinates(balticgrid)[,1], latitude = coordinates(balticgrid)[,2])
baltdat<-cbind(baltdat,baltdat2)
baltdat$knip<- rep(1,nrow(baltdat))
baltdat$knip[baltdat$longitude < 10.3 & baltdat$latitude > 57.3]<-NA
baltdat$knip[baltdat$longitude < 10 & baltdat$latitude > 56.5]<-NA
baltdat$knip[baltdat$longitude > 10 & baltdat$longitude<12 & baltdat$latitude > 57.8]<-NA
baltdat<-subset(baltdat,!(is.na(baltdat$knip)))
# now get average state
whole <- c(mean(baltdat$Q25_state,na.rm=T),mean(baltdat$Q50_state, na.rm=T),mean(baltdat$Q75_state, na.rm=T),mean(baltdat$onof_state1,na.rm=T),mean(baltdat$onof_state2,na.rm=T))
whole <- data.frame("whole region",whole[1],whole[2],whole[3],whole[4],whole[5],1,1)
colnames(whole) <-  c("msfd","stateQ25","stateQ50","stateQ75","stateonof1","stateonof2","fraction area","fraction_2dec")
# now per habitat
baltdat <- subset(baltdat,!(is.na(baltdat$depth)))
habitatQ25 <- aggregate(baltdat$Q25_state,by=list(baltdat$msfd_habitat),FUN="mean",na.rm=T)
habitatQ50 <- aggregate(baltdat$Q50_state,by=list(baltdat$msfd_habitat),FUN="mean",na.rm=T)
habitatQ75 <- aggregate(baltdat$Q75_state,by=list(baltdat$msfd_habitat),FUN="mean",na.rm=T)
habitatOnof1 <- aggregate(baltdat$onof_state1,by=list(baltdat$msfd_habitat),FUN="mean",na.rm=T)
habitatOnof2 <- aggregate(baltdat$onof_state2,by=list(baltdat$msfd_habitat),FUN="mean",na.rm=T)
habitat_tot <- cbind(habitatQ25,habitatQ50[,2],habitatQ75[,2],habitatOnof1[,2],habitatOnof2[,2])
# calculate total surface area
totarea <- aggregate(baltdat$area_sqkm,by=list(baltdat$msfd_habitat),FUN="sum",na.rm=T)
totarea$frac<-totarea$x/(sum(totarea$x))
totarea$frac2 <- round(totarea$frac, digits = 2)
habitat_tot <- cbind(habitat_tot,totarea$frac,totarea$frac2)
msfd_imp <- subset(habitat_tot,(habitat_tot$Group.1 %in% c("Circalittoral mixed sediment","Circalittoral mud",
"Offshore circalittoral mud","Circalittoral sand",
"Infralittoral mixed sediment","Offshore circalittoral mixed sediment")))
msfd_imp <- as.data.frame(msfd_imp)
colnames(msfd_imp) <-  c("msfd","stateQ25","stateQ50","stateQ75","stateonof1","stateonof2","fraction area","fraction_2dec")
msfd_imp$msfd <- as.character(msfd_imp$msfd)
#calculate weighted per surface area, average for the other regions
remreg <- subset(habitat_tot,!(habitat_tot$Group.1 %in% c("Circalittoral mixed sediment","Circalittoral mud",
"Offshore circalittoral mud","Circalittoral sand",
"Infralittoral mixed sediment","Offshore circalittoral mixed sediment")))
other <- remreg[,7]*remreg[,2:6]
other <- colSums(other)/sum(remreg[,7])
other <- data.frame("others",other[1],other[2],other[3],other[4],other[5],sum(remreg[,7]),sum(remreg[,8]))
colnames(other) <- c("msfd","stateQ25","stateQ50","stateQ75","stateonof1","stateonof2","fraction area","fraction_2dec")
statehabitat <- rbind(whole,msfd_imp,other)
statehabitat <- statehabitat[order(-statehabitat$fraction_2dec),]
statehabitat
